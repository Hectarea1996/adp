# The ADP User Guide

Welcome to the ADP User Guide\! Here you will learn how to add documentation to your projects using ADP\. ADP can be divided in two groups of functions\. The API functions and Guide function\. However\, despite that distinction all the functions can be mixed to generate your documentation\.

I will try to do my best explaining how to use ADP\. If this is not sufficient\, note that every piece of documentation of ADP has been generated by itself\. So you can see the source code and see how ADP has been used\. For example\, this file was generated using the source located at ``` guides/user-guide.lisp ```\.

* [The ADP User Guide](/docs/user-guide.md#the-adp-user-guide)
  * [Setting up ADP](/docs/user-guide.md#setting-up-adp)
  * [Selecting a file to write in](/docs/user-guide.md#selecting-a-file-to-write-in)
  * [Functions to generate the API](/docs/user-guide.md#functions-to-generate-the-api)
  * [Functions to generate guides\.](/docs/user-guide.md#functions-to-generate-guides)
    * [Headers](/docs/user-guide.md#headers)
* [This is a header](/docs/user-guide.md#this-is-a-header)
  * [This is a subheader](/docs/user-guide.md#this-is-a-subheader)
    * [This is a subsubheader](/docs/user-guide.md#this-is-a-subsubheader)
    * [Text](/docs/user-guide.md#text)
    * [Tables](/docs/user-guide.md#tables)
    * [Lists](/docs/user-guide.md#lists)
    * [Text enrichment](/docs/user-guide.md#text-enrichment)
    * [Images](/docs/user-guide.md#images)
    * [Code blocks](/docs/user-guide.md#code-blocks)
  * [Generating the documentation](/docs/user-guide.md#generating-the-documentation)
  * [Cross references](/docs/user-guide.md#cross-references)
    * [Header\-tags](/docs/user-guide.md#header-tags)
    * [Function\-tags\, symbol\-tags and type\-tags](/docs/user-guide.md#function-tags-symbol-tags-and-type-tags)
    * [Code\-tags](/docs/user-guide.md#code-tags)
    * [Quoting\, commenting\, hiding and removing your code](/docs/user-guide.md#quoting-commenting-hiding-and-removing-your-code)
  * [Tips and final comments](/docs/user-guide.md#tips-and-final-comments)

## Setting up ADP

After installing ADP\, you must add it as a dependency in your project\, like you have been doing for every project you want to use\. For example\, if you have a system like this\:

`````Lisp
(ASDF/DEFSYSTEM:DEFSYSTEM :MY-SYSTEM
  ...
  :DEPENDS-ON
  (:UIOP :ALEXANDRIA)
  ...)
`````

You only need to add ``` :adp ``` to the ``` :depends-on ``` list\.

`````Lisp
(ASDF/DEFSYSTEM:DEFSYSTEM :MY-SYSTEM
  ...
  :DEPENDS-ON
  (:UIOP :ALEXANDRIA :ADP)
  ...)
`````

Your system is now ready to use ADP\.

## Selecting a file to write in

Before start using the macros to write documentation\, we need to select a file where to store it\. We can do this using the [ADP\:IN\-FILE](/docs/user-api.md#macro-in-file) macro\. You can always add this macro after [IN\-PACKAGE](http://www.lispworks.com/reference/HyperSpec/Body/m_in_pkg.htm)\.

`````Lisp
(IN-PACKAGE :MY-PKG)

(ADP:IN-FILE #P"docs/my-file")
`````

We need to pass a pathname to [ADP\:IN\-FILE](/docs/user-api.md#macro-in-file)\. This pathname will be relative to the system\'s root directory\. So\, in this case a file named ``` my-file ``` will be created inside the ``` docs ``` directory in your system\'s root directory\. Besides\, note that the pathname does not include an extension\. This is because later you can select between different styles and each style will generate different types of files\. After writing this line of code we can start to use the rest of the macros\.

## Functions to generate the API

I\'m sure your code defines a lot of things like functions\, macros and symbols\. In order to do that you have had to use define macros like [DEFUN](http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm)\, [DEFMACRO](http://www.lispworks.com/reference/HyperSpec/Body/m_defmac.htm) or [DEFPARAMETER](http://www.lispworks.com/reference/HyperSpec/Body/m_defpar.htm)\. Print some documentation of this definitions is very easy with ADP\. For example\, consider this function definition\:

`````Lisp
(DEFUN ADP::FOO (A B C) "Multiply a by the sum of b and c." (* A (+ B C)))
`````

If you want to generate documentation of this definition you only need to use the macro [ADP\:DEFUN](/docs/user-api.md#macro-defun) instead of [DEFUN](http://www.lispworks.com/reference/HyperSpec/Body/m_defun.htm)\.

`````Lisp
(ADP:DEFUN ADP::FOO (A B C) "Multiply a by the sum of b and c." (* A (+ B C)))
`````

And you will see something like this\:

#### Function: FOO

```Lisp
(defun ADP::FOO (A B C)
  ...)
```

````
Multiply a by the sum of b and c.
````

That\'s all\! Actually\, note that if you load your project as always after changing some defuns\, you will see that nothing happens\. Your system is loaded normally and nothing changes\. This is because the documentation generation is disabled by default\. So\, even if you add ADP code\, the original code remains the same\.

Same as with [ADP\:DEFUN](/docs/user-api.md#macro-defun)\, every macro that defines something is redefined to print documentation\. You can see every macro here\: [API reference functions](/docs/user-api.md#api-reference-functions)

## Functions to generate guides\.

The other group of functions are intended to generate guides and tutorials \(like this one\)\. But you can use them wherever you want and however you want\. Even you can use them together with the API functions above\.

### Headers

You can add headers in your documentation\. In other words\, they work as titles or subtitles\. You can this way organize your guide with different sections \(like I do in this guide\)\. The macros that add headers are [ADP\:HEADER](/docs/user-api.md#macro-header)\, [ADP\:SUBHEADER](/docs/user-api.md#macro-subheader) and [ADP\:SUBSUBHEADER](/docs/user-api.md#macro-subsubheader)\. They need a string as the first argument\. For example\, if I write this\:

`````Lisp
(ADP:HEADER "This is a header")

(ADP:SUBHEADER "This is a subheader")

(ADP:SUBSUBHEADER "This is a subsubheader")
`````

You will see this\:

# This is a header

## This is a subheader

### This is a subsubheader

### Text

When you want to add text you must use the macro [ADP\:TEXT](/docs/user-api.md#macro-text)\. It receives a variable number of arguments\. Each argument is evaluated at run\-time and its result is [PRINC](http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm)\-ed\. Then\, all the content that has been [PRINC](http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm)\-ed is concatenated into a single string and finally it is printed in the documentation file\. For example\:

`````Lisp
(ADP:TEXT "This is the text macro. The result of 3+4 is " (+ 3 4)
          ". As we will see later you can enrich the text with "
          (ADP:BOLD "bold words") ", " (ADP:ITALIC "italic words") ", "
          (ADP:EMPHASIS "emphasis words") " and more.")
`````

If I use that right now\:

This is the text macro\. The result of 3\+4 is 7\. As we will see later you can enrich the text with **bold words**\, _italic words_\, ***emphasis words*** and more\.

### Tables

You can add tables using the macro [ADP\:TABLE](/docs/user-api.md#macro-table)\. The best way to see how to use it is an example\. Imagine we want to show some data stored in some variables\.

`````Lisp
(DEFPARAMETER ADP::PETER-INFO '(34 "Peter Garcia" 1435))

(DEFPARAMETER ADP::MARIA-INFO '(27 "Maria Martinez" 1765))

(DEFPARAMETER ADP::LAURA-INFO '(53 "Laura Beneyto" 1543))

(DEFUN ADP::GET-AGE (INFO) (FIRST INFO))

(DEFUN ADP::GET-NAME (INFO) (SECOND INFO))

(DEFUN ADP::GET-SALARY (INFO) (THIRD INFO))
`````

Now we can create a table like this\:

`````Lisp
(ADP:TABLE ((ADP:CELL "Age") (ADP:CELL "Name") (ADP:CELL "Salary"))
           ((ADP:CELL (ADP::GET-AGE ADP::PETER-INFO))
            (ADP:CELL (ADP::GET-NAME ADP::PETER-INFO))
            (ADP:CELL (ADP::GET-SALARY ADP::PETER-INFO) "€"))
           ((ADP:CELL (ADP::GET-AGE ADP::MARIA-INFO))
            (ADP:CELL (ADP::GET-NAME ADP::MARIA-INFO))
            (ADP:CELL (ADP::GET-SALARY ADP::MARIA-INFO) "€"))
           ((ADP:CELL (ADP::GET-AGE ADP::LAURA-INFO))
            (ADP:CELL (ADP::GET-NAME ADP::LAURA-INFO))
            (ADP:CELL (ADP::GET-SALARY ADP::LAURA-INFO) "€")))
`````

And you will see this\:

| Age | Name | Salary |
| --- | --- | --- |
| 34 | Peter Garcia | 1435€ |
| 27 | Maria Martinez | 1765€ |
| 53 | Laura Beneyto | 1543€ |


Note that in the _Salary_ column we used multiple values in each cell\. Each cell can accept multiple values and they are treated as if they are in the [ADP\:TEXT](/docs/user-api.md#macro-text) macro\. In other words\, each element in a cell is [PRINC](http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm)\-ed and the results are concatenated\.

### Lists

You can add lists with [ADP\:ITEMIZE](/docs/user-api.md#macro-itemize)\. For example\:

`````Lisp
(ADP:ITEMIZE (ADP:ITEM "Vegetables:")
             (ADP:ITEMIZE (ADP:ITEM 3 " peppers:")
                          (ADP:ITEMIZE (ADP:ITEM 1 " green pepper")
                                       (ADP:ITEM (- 3 1) " red pepper"))
                          (ADP:ITEM 0.25 "Kg of carrots"))
             (ADP:ITEM "Fruits:")
             (ADP:ITEMIZE (ADP:ITEM 0.5 "Kg of apples")
                          (ADP:ITEM 6 " oranges")))
`````

You will see this\:

* Vegetables\:
  * 3 peppers\:
    * 1 green pepper
    * 2 red pepper
  * 0\.25Kg of carrots
* Fruits\:
  * 0\.5Kg of apples
  * 6 oranges

Note that each item inside [ADP\:ITEMIZE](/docs/user-api.md#macro-itemize) is a list starting with ``` ITEM ``` or ``` ITEMIZE ```\. When you use ``` ITEM ``` every object will be [PRINC](http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm)\-ed and then concatenated\. In other words\, it works the same as [ADP\:TEXT](/docs/user-api.md#macro-text) or [ADP\:TABLE](/docs/user-api.md#macro-table)\. On the other hand\, when using ``` ITEMIZE ``` you are indicating that you want a sublist of items\.

### Text enrichment

Inside a [ADP\:TEXT](/docs/user-api.md#macro-text) form\, a ``` CELL ``` from a [ADP\:TABLE](/docs/user-api.md#macro-table) form and a ``` ITEM ``` form a [ADP\:ITEMIZE](/docs/user-api.md#macro-itemize) form\, we can enrich the text with the macros [ADP\:BOLD](/docs/user-api.md#macro-bold)\, [ADP\:ITALIC](/docs/user-api.md#macro-italic)\, [ADP\:EMPHASIS](/docs/user-api.md#macro-emphasis) and [ADP\:WEB\-LINK](/docs/user-api.md#macro-web-link)\. For example\:

`````Lisp
(ADP:TEXT "As " (ADP:BOLD "Andrew") " said: "
          (ADP:ITALIC "You only need " (+ 1 2 3)) " "
          (ADP:WEB-LINK "coins" "https://en.wikipedia.org/wiki/Coin") " "
          (ADP:ITALIC "to enter in") " " (ADP:EMPHASIS "The Giant Red Tree."))
`````

You will see this\:

As **Andrew** said\: _You only need 6_ [coins](https://en.wikipedia.org/wiki/Coin) _to enter in_ ***The Giant Red Tree\.***

Note that spaces are placed out of enrichment functions \(after ``` italic ``` and ``` web-link ``` calls\)\. Also\, you cannot nest calls of [ADP\:BOLD](/docs/user-api.md#macro-bold)\, [ADP\:ITALIC](/docs/user-api.md#macro-italic)\, [ADP\:EMPHASIS](/docs/user-api.md#macro-emphasis) and [ADP\:WEB\-LINK](/docs/user-api.md#macro-web-link)\. For example\, if you try this\:

`````Lisp
(ADP:TEXT (ADP:BOLD (ADP:ITALIC "This should be emphasis.")))
`````

an error will be raised\.

### Images

You can add images with the macro [ADP\:IMAGE](/docs/user-api.md#macro-image)\. For example\, an image is located at ``` guides/images/ ```\. If I evaluate the next expression\:

`````Lisp
(ADP:IMAGE "Lisp logo" #P"guides/images/Lisp_logo.svg")
`````

I get this\:

![Lisp logo](/guides/images/Lisp_logo.svg)

The first argument is the alternative text of the image\. If for some reason the image cannot be loaded in some web page\, the alternative text is used instead\. The second argument is the pathname of the image\, relative to the system\'s root directory\.

### Code blocks

A good Lisp tutorial must include Lisp code examples\. ADP defines some macros to print code blocks\: [ADP\:CODE\-BLOCK](/docs/user-api.md#macro-code-block)\, [ADP\:VERBATIM\-CODE\-BLOCK](/docs/user-api.md#macro-verbatim-code-block) and [ADP\:CODE\-EXAMPLE](/docs/user-api.md#macro-code-example)\. The first macro does not evaluate the code\. So\, for example if you write this\:

`````Lisp
(ADP:CODE-BLOCK NIL
  (THIS IS NOT (VALID CODE))
  (BUT IT (IS (OK))))
`````

You will see\:

`````Lisp
(THIS IS NOT (VALID CODE))

(BUT IT (IS (OK)))
`````

Note that ``` NIL ``` or\, equivalently\, ``` () ``` is used after ``` code-block ```\. This is because we can pass some symbols to [ADP\:CODE\-BLOCK](/docs/user-api.md#macro-code-block) in order to change a bit how it works\. But\, we will see that in later sections\.

The macro [ADP\:VERBATIM\-CODE\-BLOCK](/docs/user-api.md#macro-verbatim-code-block) allows you to write non\-Lisp code\. It must receive two strings denoting the programming language to be used and the code itself\. For example\, writing this\:

`````Lisp
(ADP:VERBATIM-CODE-BLOCK "C++" "int main (){

  // We initialize some vars
  int n = 5;
  int m = 10;
 
  // We print hello world
  std::count << \"Hello world\" << std::endl;

  return 0;

}")
`````

You will see this\:

`````C++
int main (){

  // We initialize some vars
  int n = 5;
  int m = 10;
 
  // We print hello world
  std::count << "Hello world" << std::endl;

  return 0;

}
`````

Lastly\, [ADP\:CODE\-EXAMPLE](/docs/user-api.md#macro-code-example) evaluate the Lisp code you write on it\. And what is more\, it prints the standard output as well as the returned values\. For example\, writing this\:

`````Lisp
(ADP:CODE-EXAMPLE
  (LOOP FOR I FROM 0 BELOW 10
        DO (PRINT I))
  (VALUES "Hello" "world"))
`````

You will see\:

```Lisp
(LOOP FOR I FROM 0 BELOW 10
      DO (PRINT I))

(VALUES "Hello" "world")

0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
"Hello"
"world"
```

## Generating the documentation

There are still some useful macros that I didn\'t explain yet\. However\, I think it is now a good time to learn how to actually generate the documentation\. You may have multiple files where the macros explained above are used\. Also\, all the information is associated with a file because you have used the macro [ADP\:IN\-FILE](/docs/user-api.md#macro-in-file) whereever you have needed\.

Now it is time to generate the files and print the documentation\. The function that must be used now is [ADP\:LOAD\-SYSTEM](/docs/user-api.md#function-load-system)\. As the name suggests\, you are going to load your system\. In fact\, it will load your system with the documentation generation enabled so\, while forms are evaluated the documentation is gathered\. When the system is completely loaded\, the file generation and documentation printing begins\. For example\, if your system is named ``` MY-SYSTEM ```\, then you can eval this expression in the REPL\:

`````Lisp
(ADP:LOAD-SYSTEM :MY-SYSTEM :GITHUB-MD)
`````

The second argument is the desired style\. In this case the used style is ``` GITHUB-MD ```\. This style generates ``` md ``` files to be used in the GitHub platform\.

I did this as well to generate the ADP documentation\. If you take a look at the file ``` adp.asd ``` you will see a system named ``` adp/doc ```\. That system loads every file that is needed to generate all the ADP documentation\. And I did that using this expression\:

`````Lisp
(ADP:LOAD-SYSTEM :ADP/DOC :GITHUB-MD)
`````

And that\'s all\! The documentation is ready to be read\.

## Cross references

ADP supports cross references with tags\. A tag is a just a symbol with some information associated\. There are six types of tags\: header\-tags\, function\-tags\, symbol\-tags\, type\-tags\, file\-tags and code\-tags\.

### Header\-tags

A header\-tag is a symbol with a header associated\. We have already seen how to add a header to the documentation\. But I didn\'t say that the macros [ADP\:HEADER](/docs/user-api.md#macro-header)\, [ADP\:SUBHEADER](/docs/user-api.md#macro-subheader) and [ADP\:SUBSUBHEADER](/docs/user-api.md#macro-subsubheader) receives a second optional argument\. As you can imagine\, this second argument must be a symbol that will be converted to a header tag\. For example\, the first header of this file is created with this expression\:

`````Lisp
(ADP:HEADER "The ADP User Guide" USER-GUIDE-HEADER)
`````

Now the symbol ``` user-guide-header ``` is a header\-tag\. We can make a reference to that header with the macro [ADP\:HEADER\-REF](/docs/user-api.md#macro-header-ref)\. For example\, if I write this\:

`````Lisp
(ADP:TEXT "Go to the top: " (ADP:HEADER-REF USER-GUIDE-HEADER))
`````

Then you will see this\:

Go to the top\: [The ADP User Guide](/docs/user-guide.md#the-adp-user-guide)

Note that the macro is used inside a [ADP\:TEXT](/docs/user-api.md#macro-text) form\. Same as with [ADP\:BOLD](/docs/user-api.md#macro-bold) or [ADP\:ITALIC](/docs/user-api.md#macro-italic)\, [ADP\:HEADER\-REF](/docs/user-api.md#macro-header-ref) only can be used inside [ADP\:TEXT](/docs/user-api.md#macro-text)\, [ADP\:TABLE](/docs/user-api.md#macro-table) or [ADP\:ITEMIZE](/docs/user-api.md#macro-itemize)\.

### Function\-tags\, symbol\-tags and type\-tags

These tags are symbols associated with a function\, a variable or a type respectively\. More specifically\, the macros used to define things like [ADP\:DEFUN](/docs/user-api.md#macro-defun)\, [ADP\:DEFPARAMETER](/docs/user-api.md#macro-defparameter) or [ADP\:DEFSTRUCT](/docs/user-api.md#macro-defstruct) can create automatically a function\-tag\, a symbol\-tag or a type\-tag respectively\. The tag created is the symbol of the name of the function\, variable or type defined respectively\. ADP defines three types of tags because the same symbol can refer to a function\, a variable and a type simultaneously\. The next list shows what type of tags are defined by which macros\:

* Function\-tags\:
  * [ADP\:DEFGENERIC](/docs/user-api.md#macro-defgeneric)
  * [ADP\:DEFINE\-MODIFY\-MACRO](/docs/user-api.md#macro-define-modify-macro)
  * [ADP\:DEFMACRO](/docs/user-api.md#macro-defmacro)
  * [ADP\:DEFUN](/docs/user-api.md#macro-defun)
* Symbol\-tags\:
  * [ADP\:DEFCONSTANT](/docs/user-api.md#macro-defconstant)
  * [ADP\:DEFINE\-SYMBOL\-MACRO](/docs/user-api.md#macro-define-symbol-macro)
  * [ADP\:DEFPARAMETER](/docs/user-api.md#macro-defparameter)
  * [ADP\:DEFVAR](/docs/user-api.md#macro-defvar)
* Type\-tags\:
  * [ADP\:DEFCLASS](/docs/user-api.md#macro-defclass)
  * [ADP\:DEFINE\-CONDITION](/docs/user-api.md#macro-define-condition)
  * [ADP\:DEFSTRUCT](/docs/user-api.md#macro-defstruct)
  * [ADP\:DEFTYPE](/docs/user-api.md#macro-deftype)

Same as with header\-tags\, we can make reference to functions\, variables and types with [ADP\:FUNCTION\-REF](/docs/user-api.md#macro-function-ref)\, [ADP\:SYMBOL\-REF](/docs/user-api.md#macro-symbol-ref) and [ADP\:TYPE\-REF](/docs/user-api.md#macro-type-ref)\. For example\, to make a reference to an ADP macro\:

`````Lisp
(ADP:TEXT "A reference to an ADP macro: " (ADP:FUNCTION-REF ADP:HEADER))
`````

You will see this\:

A reference to an ADP macro\: [ADP\:HEADER](/docs/user-api.md#macro-header)

Note again that [ADP\:FUNCTION\-REF](/docs/user-api.md#macro-function-ref) only can be used inside [ADP\:TEXT](/docs/user-api.md#macro-text)\, [ADP\:CELL](/docs/user-api.md#macro-cell) or [ADP\:ITEM](/docs/user-api.md#macro-item)\. The same goes to [ADP\:SYMBOL\-REF](/docs/user-api.md#macro-symbol-ref) and [ADP\:TYPE\-REF](/docs/user-api.md#macro-type-ref)\.

A cool thing about cross references is that you can make a reference to something that is not currently defined but will be\. For example\, a variable will be defined at the end of this file but we can make a reference now\. I\'m writing the next expression\:

`````Lisp
(ADP:TEXT "In the future, we will define the symbol "
          (ADP:SYMBOL-REF ADP::A-PARAMETER-DEFINED-AT-THE-END-OF-THE-FILE) ".")
`````

In the future\, we will define the symbol [ADP\:\:A\-PARAMETER\-DEFINED\-AT\-THE\-END\-OF\-THE\-FILE](/docs/user-guide.md#variable-a-parameter-defined-at-the-end-of-the-file)\.

Lastly\, an example using a type\-tag\:

`````Lisp
(ADP:TEXT "Using a type tag: " (ADP:TYPE-REF ALSO-A-TYPE?))
`````

Using a type tag\: [ALSO\-A\-TYPE\?](/docs/user-guide.md#type-also-a-type)

### Code\-tags

Code\-tags work differently to those we have just seen above\. Code\-tags are used inside the [ADP\:CODE\-BLOCK](/docs/user-api.md#macro-code-block) macro\. Imagine that you are making a tutorial\. You are explaining how some piece of code works and you test that code in a different file to make sure your tutorial is well done\. But one day\, you decide to change your code\. Now the tutorial needs to be changed too\. To avoid writing your code twice you can use code\-tags\. Suppose that your code looks like this\:

`````Lisp
(ADP:DEFUN SUM-LIST (INT-LIST)
  (LOOP FOR NUM IN INT-LIST
        SUM NUM))

(SUM-LIST '(1 2 3))
`````

And you write in your tutorial that the function ``` sum-list ``` can be used the way you tested before\:

`````Lisp
(ADP:TEXT "The sum-list function can be used like this:")

(ADP:CODE-BLOCK NIL
  (SUM-LIST '(1 2 3)))
`````

But now you decide to use vectors rather than lists\. You didn\'t use code\-tags so you must change your code in two different places\. Let\'s create now a code\-tag using the macro [ADP\:CODE\-TAG](/docs/user-api.md#macro-code-tag)\:

`````Lisp
(ADP:DEFUN SUM-LIST (INT-LIST)
  (LOOP FOR NUM IN INT-LIST
        SUM NUM))

(ADP:CODE-TAG (SUM-LIST-EXAMPLE)
  (SUM-LIST '(1 2 3)))
`````

A code\-tag named ``` sum-list-example ``` is created and you can now use it in the tutorial\:

`````Lisp
(ADP:TEXT "The sum-list function can be used like this:")

(ADP:CODE-BLOCK (SUM-LIST-EXAMPLE)
  SUM-LIST-EXAMPLE)
`````

First we indicate in the list after ``` code-block ``` that we will use the code tag named ``` sum-list-example ```\. Then\, we use it\. Now\, each time you change the call to ``` sum-list ``` in your test code the tutorial will be automatically changed\. You can specify as many tags as you want in both [ADP\:CODE\-TAG](/docs/user-api.md#macro-code-tag) and [ADP\:CODE\-BLOCK](/docs/user-api.md#macro-code-block) macros\.

Let\'s see a live example\. Do you remember the symbol [ADP\:\:A\-PARAMETER\-DEFINED\-AT\-THE\-END\-OF\-THE\-FILE](/docs/user-guide.md#variable-a-parameter-defined-at-the-end-of-the-file) and the type [ALSO\-A\-TYPE\?](/docs/user-guide.md#type-also-a-type)\?\. In the source file I have written this\:

`````Lisp
(ADP:CODE-TAG (END-PARAMETER-CODE)
  (ADP:DEFPARAMETER ADP::A-PARAMETER-DEFINED-AT-THE-END-OF-THE-FILE T))

(ADP:CODE-TAG (END-TYPE-CODE)
  (ADP:DEFTYPE ALSO-A-TYPE? () 'VECTOR))
`````

So\, if I write this\:

`````Lisp
(ADP:CODE-BLOCK (END-PARAMETER-CODE END-TYPE-CODE)
  END-TYPE-CODE
  (SOME-CODE-IN (THE-MIDDLE))
  END-PARAMETER-CODE)
`````

You will see this\:

`````Lisp
(ADP:DEFTYPE ALSO-A-TYPE? () 'VECTOR)

(SOME-CODE-IN (THE-MIDDLE))

(ADP:DEFPARAMETER ADP::A-PARAMETER-DEFINED-AT-THE-END-OF-THE-FILE T)
`````

### Quoting\, commenting\, hiding and removing your code

Code tags are great but [ADP\:CODE\-TAG](/docs/user-api.md#macro-code-tag) will expand to the code you write\. Sometimes you will want to create a tag to some piece of code but not to evaluate it\. In that case we can quote the code using the form ``` code-quote ```\. For example\, you can write this\:

`````Lisp
(ADP:CODE-BLOCK (QUOTED-CODE)
  QUOTED-CODE)

(ADP:CODE-TAG (QUOTED-CODE)
  (ADP:CODE-QUOTE (THIS IS A (FORM I (DONT WANT) TO EVALUATE))))
`````

And you will see this\:

`````Lisp
(THIS IS A (FORM I (DONT WANT) TO EVALUATE))
`````

Comments are ignored when Lisp is reading an expression\, so you cannot place a regular comment inside a [ADP\:CODE\-BLOCK](/docs/user-api.md#macro-code-block) form and expect to see it printed\. If you want to print a comment you need to use the form ``` code-comment ``` inside [ADP\:CODE\-TAG](/docs/user-api.md#macro-code-tag)\. It just receives a string\. For example\, if I write this\:

`````Lisp
(ADP:CODE-BLOCK (COMMENTED-CODE)
  COMMENTED-CODE)

(ADP:CODE-TAG (COMMENTED-CODE)
  (ADP:CODE-QUOTE
   (LET ((X 5))
     (ADP:CODE-COMMENT "We print the number 5" (PRINT X)))))
`````

you will see this\:

`````Lisp
(LET ((X 5))
  ;; We print the number 5
  (PRINT X))
`````

When explaining some piece of code you should focus on the important parts\. Or\, equivalently\, you should hide the irrelevant ones\. You can do that using the form ``` code-hide ```\. For example\, if I write this\:

`````Lisp
(ADP:CODE-BLOCK (HIDDEN-CODE)
  HIDDEN-CODE)

(ADP:CODE-TAG (HIDDEN-CODE)
  (ADP:CODE-QUOTE
   (LET ((ADP:CODE-HIDE NIL (X 5) (Y 6)))
     (DOING STUFF)
     (DOING MORE STUFF))))
`````

You will see this\:

`````Lisp
(LET (...)
  (DOING STUFF)
  (DOING MORE STUFF))
`````

Note that the hidden code is shown as three dots \(\'\.\.\.\'\)\. This form receives as first argument a list of tags\. If the list is empty\, the hide of the code will take effect always\, but you can specify when to hide or remove your code specifing a tag\. Imagine you have the following piece of code in your project\:

`````Lisp
(DEFUN ADP::SOME-LARGE-FUNCTION (X Y Z)
  (LET ((POST-X (1+ X)) (POST-Y (1+ Y)) (POST-Z (1+ Z)))
    (LOOP FOR I FROM 0 BELOW 10
          COLLECT POST-X INTO X-LIST
          COLLECT POST-Y INTO Y-LIST
          COLLECT (CONS POST-Y POST-Z) INTO YZ-LIST
          FINALLY (RETURN (VALUES X-LIST Y-LIST YZ-LIST)))))
`````

The example can be large and hard to read as well\. This piece of code uses the variables ``` X ```\, ``` Y ``` and ``` Z ``` in different ways and you may want to explain how each one participates in the function\. We can show different parts of the code depending of the tags we specify\. In this case you can write this\:

`````Lisp
(ADP:CODE-TAG (X-TAG Y-TAG Z-TAG)
  (DEFUN ADP::SOME-LARGE-FUNCTION (X Y Z)
    (LET ((ADP:CODE-HIDE (Y-TAG Z-TAG) (POST-X (1+ X)))
          (ADP:CODE-HIDE (X-TAG Z-TAG) (POST-Y (1+ Y)))
          (ADP:CODE-HIDE (X-TAG Y-TAG) (POST-Z (1+ Z))))
      (LOOP FOR I FROM 0 BELOW 10
            COLLECT (ADP:CODE-HIDE (Y-TAG Z-TAG) POST-X INTO X-LIST)
            COLLECT (ADP:CODE-HIDE (X-TAG Z-TAG) POST-Y INTO Y-LIST)
            COLLECT (ADP:CODE-HIDE (X-TAG) (CONS POST-Y POST-Z) INTO YZ-LIST)
            FINALLY (RETURN
                     (VALUES (ADP:CODE-HIDE (Y-TAG Z-TAG) X-LIST)
                             (ADP:CODE-HIDE (X-TAG Z-TAG) Y-LIST)
                             (ADP:CODE-HIDE (X-TAG) YZ-LIST)))))))
`````

Note that we are using three tags here\. Also\, we are indicating when a piece of code must be hidden using the corresponding tags\. If I write this\:

`````Lisp
(ADP:CODE-BLOCK (X-TAG)
  X-TAG)
`````

You will see this\:

`````Lisp
(DEFUN ADP::SOME-LARGE-FUNCTION (X Y Z)
  (LET ((POST-X (1+ X)) ... ...)
    (LOOP FOR I FROM 0 BELOW 10
          COLLECT POST-X INTO X-LIST
          COLLECT ...
          COLLECT ...
          FINALLY (RETURN (VALUES X-LIST ... ...)))))
`````

Same occurs if I use ``` Y-TAG ``` and ``` Z-TAG ```\. If I write this\:

`````Lisp
(ADP:CODE-BLOCK (Y-TAG)
  Y-TAG)

(ADP:CODE-BLOCK (Z-TAG)
  Z-TAG)
`````

You will see this\:

`````Lisp
(DEFUN ADP::SOME-LARGE-FUNCTION (X Y Z)
  (LET (... (POST-Y (1+ Y)) ...)
    (LOOP FOR I FROM 0 BELOW 10
          COLLECT ...
          COLLECT POST-Y INTO Y-LIST
          COLLECT (CONS POST-Y POST-Z) INTO YZ-LIST
          FINALLY (RETURN (VALUES ... Y-LIST YZ-LIST)))))
`````

`````Lisp
(DEFUN ADP::SOME-LARGE-FUNCTION (X Y Z)
  (LET (... ... (POST-Z (1+ Z)))
    (LOOP FOR I FROM 0 BELOW 10
          COLLECT ...
          COLLECT ...
          COLLECT (CONS POST-Y POST-Z) INTO YZ-LIST
          FINALLY (RETURN (VALUES ... ... YZ-LIST)))))
`````

You can also remove the code using the form ``` code-remove ```\. It works the same as ``` code-hide ```\. For example\, you can create a making\-function explanation\:

`````Lisp
(ADP:CODE-BLOCK (MAKING-FUNCTION-1 MAKING-FUNCTION-2)
  MAKING-FUNCTION-1
  MAKING-FUNCTION-2)

(ADP:CODE-TAG (MAKING-FUNCTION-1 MAKING-FUNCTION-2)
  (DEFUN ADP::PRINT-5-6 ()
    (ADP:CODE-HIDE (MAKING-FUNCTION-2) (ADP:CODE-COMMENT "We print 5")
     (PRINT 5))
    (ADP:CODE-REMOVE (MAKING-FUNCTION-1) (ADP:CODE-COMMENT "And we print 6")
     (PRINT 6))))
`````

And you will see this\:

`````Lisp
(DEFUN ADP::PRINT-5-6 ()
  ;; We print 5
  (PRINT 5))

(DEFUN ADP::PRINT-5-6 ()
  ...
  ;; And we print 6
  (PRINT 6))
`````

## Tips and final comments

I hope this guide is useful\. I usually see Common Lisp projects that looks awesome but they lack guides or even documentation\. That\'s why I started to document all my projects and then I realized that I needed some tool to make it easier\. I know that there are already other documentation generators\, but none of them suits my needs\. Luckily\, Common Lisp makes doing this kind of tools relatively easy compared to other languages\. Lastly\, I want to give you some tips or ways to use ADP that I ended up doing myself\.

* ***Use a different system for documentation generation***\: I recommend to use a different system to indicate all the files you need to load to generate the documentation\. So\, if you have a system named ``` MY-SYSTEM ``` then create another system named ``` MY-SYSTEM/DOCS ```\. Although ADP will not execute anything unless you use the function [ADP\:LOAD\-SYSTEM](/docs/user-api.md#function-load-system)\, I think this should make your projects cleaner\. And\, let\'s be honest\, I\'m still learning the language and I don\'t want to break other people\'s code\. I did this separation for ADP\, so you can see an example in the file ``` adp.asd ```\.
* ***Handling error messages***\: I tried to make informative error messages but sometimes this cannot be possible\. Or\, at least\, I can\'t do it better\. The most common errors I have had when using ADP were undefined variable errors\. Remember that [ADP\:INLINE\-CODE](/docs/user-api.md#macro-inline-code) works the same as [ADP\:TEXT](/docs/user-api.md#macro-text)\. You can\'t write ``` (inline-code name-of-function) ```\, you must write this instead ``` (inline-code "name-of-function") ``` or ``` (inline-code 'name-of-function) ```\. Also\, be careful when using [ADP\:FUNCTION\-REF](/docs/user-api.md#macro-function-ref) or similars\. If you don\'t write correctly the macro\, some implementations will treat that call as a function call and will treat the argument as a variable\. That\'s not a variable that ADP or you have defined and it is sure that it will raise an undefined variable error\.
* ***Tags belong to a package\!***\: Note that almost all the tags are actually symbols\, and symbols belong to a package\. If you define a tag and you want to make a reference to it from another package\, remember to add the package extension to the symbol name\. For example\, suppose that you define the symbol\-tag ``` MY-TAG ``` in the package ``` MY-PKG ```\. Then\, in another package you must write ``` (symbol-ref my-pkg:my-tag) ```\, or ``` (symbol-ref my-pkg::my-tag) ``` if the symbol is not exported\. And yes\, you should export the tags you want to use in other packages\.
* ***Read the API***\: Maybe reading [ADP User Interface](/docs/user-api.md#adp-user-interface) can make you understand better how some macros work \(or not\)\. At least\, you may be interested in seeing the section [Additional functions](/docs/user-api.md#additional-functions)\.
* ***That\'s all\! Enjoy using ADP\.*** I leave you with [ADP\:\:A\-PARAMETER\-DEFINED\-AT\-THE\-END\-OF\-THE\-FILE](/docs/user-guide.md#variable-a-parameter-defined-at-the-end-of-the-file) and [ALSO\-A\-TYPE\?](/docs/user-guide.md#type-also-a-type) again\.

#### Variable: A\-PARAMETER\-DEFINED\-AT\-THE\-END\-OF\-THE\-FILE

```Lisp
(defparameter ADP::A-PARAMETER-DEFINED-AT-THE-END-OF-THE-FILE T)
```

#### Type: ALSO\-A\-TYPE\?

```Lisp
(deftype ALSO-A-TYPE? NIL
  ...)
```

Go back to [Function\-tags\, symbol\-tags and type\-tags](/docs/user-guide.md#function-tags-symbol-tags-and-type-tags)

